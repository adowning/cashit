
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/**
 * This file exports the `Jackpot` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Jackpot
 * 
 */
export type JackpotModel = runtime.Types.Result.DefaultSelection<Prisma.$JackpotPayload>

export type AggregateJackpot = {
  _count: JackpotCountAggregateOutputType | null
  _avg: JackpotAvgAggregateOutputType | null
  _sum: JackpotSumAggregateOutputType | null
  _min: JackpotMinAggregateOutputType | null
  _max: JackpotMaxAggregateOutputType | null
}

export type JackpotAvgAggregateOutputType = {
  currentAmountCoins: number | null
  seedAmountCoins: number | null
  minimumBetCoins: number | null
  contributionRateBasisPoints: number | null
  probabilityPerMillion: number | null
  minimumTimeBetweenWinsMinutes: number | null
}

export type JackpotSumAggregateOutputType = {
  currentAmountCoins: number | null
  seedAmountCoins: number | null
  minimumBetCoins: number | null
  contributionRateBasisPoints: number | null
  probabilityPerMillion: number | null
  minimumTimeBetweenWinsMinutes: number | null
}

export type JackpotMinAggregateOutputType = {
  id: string | null
  type: $Enums.JackpotType | null
  currentAmountCoins: number | null
  seedAmountCoins: number | null
  minimumBetCoins: number | null
  contributionRateBasisPoints: number | null
  probabilityPerMillion: number | null
  minimumTimeBetweenWinsMinutes: number | null
  lastWonAt: Date | null
  lastWonBy: string | null
  isActive: boolean | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type JackpotMaxAggregateOutputType = {
  id: string | null
  type: $Enums.JackpotType | null
  currentAmountCoins: number | null
  seedAmountCoins: number | null
  minimumBetCoins: number | null
  contributionRateBasisPoints: number | null
  probabilityPerMillion: number | null
  minimumTimeBetweenWinsMinutes: number | null
  lastWonAt: Date | null
  lastWonBy: string | null
  isActive: boolean | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type JackpotCountAggregateOutputType = {
  id: number
  type: number
  currentAmountCoins: number
  seedAmountCoins: number
  minimumBetCoins: number
  contributionRateBasisPoints: number
  probabilityPerMillion: number
  minimumTimeBetweenWinsMinutes: number
  lastWonAt: number
  lastWonBy: number
  isActive: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type JackpotAvgAggregateInputType = {
  currentAmountCoins?: true
  seedAmountCoins?: true
  minimumBetCoins?: true
  contributionRateBasisPoints?: true
  probabilityPerMillion?: true
  minimumTimeBetweenWinsMinutes?: true
}

export type JackpotSumAggregateInputType = {
  currentAmountCoins?: true
  seedAmountCoins?: true
  minimumBetCoins?: true
  contributionRateBasisPoints?: true
  probabilityPerMillion?: true
  minimumTimeBetweenWinsMinutes?: true
}

export type JackpotMinAggregateInputType = {
  id?: true
  type?: true
  currentAmountCoins?: true
  seedAmountCoins?: true
  minimumBetCoins?: true
  contributionRateBasisPoints?: true
  probabilityPerMillion?: true
  minimumTimeBetweenWinsMinutes?: true
  lastWonAt?: true
  lastWonBy?: true
  isActive?: true
  createdAt?: true
  updatedAt?: true
}

export type JackpotMaxAggregateInputType = {
  id?: true
  type?: true
  currentAmountCoins?: true
  seedAmountCoins?: true
  minimumBetCoins?: true
  contributionRateBasisPoints?: true
  probabilityPerMillion?: true
  minimumTimeBetweenWinsMinutes?: true
  lastWonAt?: true
  lastWonBy?: true
  isActive?: true
  createdAt?: true
  updatedAt?: true
}

export type JackpotCountAggregateInputType = {
  id?: true
  type?: true
  currentAmountCoins?: true
  seedAmountCoins?: true
  minimumBetCoins?: true
  contributionRateBasisPoints?: true
  probabilityPerMillion?: true
  minimumTimeBetweenWinsMinutes?: true
  lastWonAt?: true
  lastWonBy?: true
  isActive?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type JackpotAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Jackpot to aggregate.
   */
  where?: Prisma.JackpotWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Jackpots to fetch.
   */
  orderBy?: Prisma.JackpotOrderByWithRelationInput | Prisma.JackpotOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.JackpotWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Jackpots from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Jackpots.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Jackpots
  **/
  _count?: true | JackpotCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: JackpotAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: JackpotSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: JackpotMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: JackpotMaxAggregateInputType
}

export type GetJackpotAggregateType<T extends JackpotAggregateArgs> = {
      [P in keyof T & keyof AggregateJackpot]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateJackpot[P]>
    : Prisma.GetScalarType<T[P], AggregateJackpot[P]>
}




export type JackpotGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.JackpotWhereInput
  orderBy?: Prisma.JackpotOrderByWithAggregationInput | Prisma.JackpotOrderByWithAggregationInput[]
  by: Prisma.JackpotScalarFieldEnum[] | Prisma.JackpotScalarFieldEnum
  having?: Prisma.JackpotScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: JackpotCountAggregateInputType | true
  _avg?: JackpotAvgAggregateInputType
  _sum?: JackpotSumAggregateInputType
  _min?: JackpotMinAggregateInputType
  _max?: JackpotMaxAggregateInputType
}

export type JackpotGroupByOutputType = {
  id: string
  type: $Enums.JackpotType
  currentAmountCoins: number
  seedAmountCoins: number
  minimumBetCoins: number
  contributionRateBasisPoints: number
  probabilityPerMillion: number
  minimumTimeBetweenWinsMinutes: number
  lastWonAt: Date | null
  lastWonBy: string | null
  isActive: boolean
  createdAt: Date
  updatedAt: Date
  _count: JackpotCountAggregateOutputType | null
  _avg: JackpotAvgAggregateOutputType | null
  _sum: JackpotSumAggregateOutputType | null
  _min: JackpotMinAggregateOutputType | null
  _max: JackpotMaxAggregateOutputType | null
}

type GetJackpotGroupByPayload<T extends JackpotGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<JackpotGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof JackpotGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], JackpotGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], JackpotGroupByOutputType[P]>
      }
    >
  > 



export type JackpotWhereInput = {
  AND?: Prisma.JackpotWhereInput | Prisma.JackpotWhereInput[]
  OR?: Prisma.JackpotWhereInput[]
  NOT?: Prisma.JackpotWhereInput | Prisma.JackpotWhereInput[]
  id?: Prisma.StringFilter<"Jackpot"> | string
  type?: Prisma.EnumJackpotTypeFilter<"Jackpot"> | $Enums.JackpotType
  currentAmountCoins?: Prisma.IntFilter<"Jackpot"> | number
  seedAmountCoins?: Prisma.IntFilter<"Jackpot"> | number
  minimumBetCoins?: Prisma.IntFilter<"Jackpot"> | number
  contributionRateBasisPoints?: Prisma.IntFilter<"Jackpot"> | number
  probabilityPerMillion?: Prisma.IntFilter<"Jackpot"> | number
  minimumTimeBetweenWinsMinutes?: Prisma.IntFilter<"Jackpot"> | number
  lastWonAt?: Prisma.DateTimeNullableFilter<"Jackpot"> | Date | string | null
  lastWonBy?: Prisma.StringNullableFilter<"Jackpot"> | string | null
  isActive?: Prisma.BoolFilter<"Jackpot"> | boolean
  createdAt?: Prisma.DateTimeFilter<"Jackpot"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Jackpot"> | Date | string
  contributions?: Prisma.JackpotContributionListRelationFilter
  wins?: Prisma.JackpotWinListRelationFilter
  lastWinner?: Prisma.XOR<Prisma.UserProfileNullableScalarRelationFilter, Prisma.UserProfileWhereInput> | null
}

export type JackpotOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  type?: Prisma.SortOrder
  currentAmountCoins?: Prisma.SortOrder
  seedAmountCoins?: Prisma.SortOrder
  minimumBetCoins?: Prisma.SortOrder
  contributionRateBasisPoints?: Prisma.SortOrder
  probabilityPerMillion?: Prisma.SortOrder
  minimumTimeBetweenWinsMinutes?: Prisma.SortOrder
  lastWonAt?: Prisma.SortOrderInput | Prisma.SortOrder
  lastWonBy?: Prisma.SortOrderInput | Prisma.SortOrder
  isActive?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  contributions?: Prisma.JackpotContributionOrderByRelationAggregateInput
  wins?: Prisma.JackpotWinOrderByRelationAggregateInput
  lastWinner?: Prisma.UserProfileOrderByWithRelationInput
}

export type JackpotWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.JackpotWhereInput | Prisma.JackpotWhereInput[]
  OR?: Prisma.JackpotWhereInput[]
  NOT?: Prisma.JackpotWhereInput | Prisma.JackpotWhereInput[]
  type?: Prisma.EnumJackpotTypeFilter<"Jackpot"> | $Enums.JackpotType
  currentAmountCoins?: Prisma.IntFilter<"Jackpot"> | number
  seedAmountCoins?: Prisma.IntFilter<"Jackpot"> | number
  minimumBetCoins?: Prisma.IntFilter<"Jackpot"> | number
  contributionRateBasisPoints?: Prisma.IntFilter<"Jackpot"> | number
  probabilityPerMillion?: Prisma.IntFilter<"Jackpot"> | number
  minimumTimeBetweenWinsMinutes?: Prisma.IntFilter<"Jackpot"> | number
  lastWonAt?: Prisma.DateTimeNullableFilter<"Jackpot"> | Date | string | null
  lastWonBy?: Prisma.StringNullableFilter<"Jackpot"> | string | null
  isActive?: Prisma.BoolFilter<"Jackpot"> | boolean
  createdAt?: Prisma.DateTimeFilter<"Jackpot"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Jackpot"> | Date | string
  contributions?: Prisma.JackpotContributionListRelationFilter
  wins?: Prisma.JackpotWinListRelationFilter
  lastWinner?: Prisma.XOR<Prisma.UserProfileNullableScalarRelationFilter, Prisma.UserProfileWhereInput> | null
}, "id">

export type JackpotOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  type?: Prisma.SortOrder
  currentAmountCoins?: Prisma.SortOrder
  seedAmountCoins?: Prisma.SortOrder
  minimumBetCoins?: Prisma.SortOrder
  contributionRateBasisPoints?: Prisma.SortOrder
  probabilityPerMillion?: Prisma.SortOrder
  minimumTimeBetweenWinsMinutes?: Prisma.SortOrder
  lastWonAt?: Prisma.SortOrderInput | Prisma.SortOrder
  lastWonBy?: Prisma.SortOrderInput | Prisma.SortOrder
  isActive?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.JackpotCountOrderByAggregateInput
  _avg?: Prisma.JackpotAvgOrderByAggregateInput
  _max?: Prisma.JackpotMaxOrderByAggregateInput
  _min?: Prisma.JackpotMinOrderByAggregateInput
  _sum?: Prisma.JackpotSumOrderByAggregateInput
}

export type JackpotScalarWhereWithAggregatesInput = {
  AND?: Prisma.JackpotScalarWhereWithAggregatesInput | Prisma.JackpotScalarWhereWithAggregatesInput[]
  OR?: Prisma.JackpotScalarWhereWithAggregatesInput[]
  NOT?: Prisma.JackpotScalarWhereWithAggregatesInput | Prisma.JackpotScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"Jackpot"> | string
  type?: Prisma.EnumJackpotTypeWithAggregatesFilter<"Jackpot"> | $Enums.JackpotType
  currentAmountCoins?: Prisma.IntWithAggregatesFilter<"Jackpot"> | number
  seedAmountCoins?: Prisma.IntWithAggregatesFilter<"Jackpot"> | number
  minimumBetCoins?: Prisma.IntWithAggregatesFilter<"Jackpot"> | number
  contributionRateBasisPoints?: Prisma.IntWithAggregatesFilter<"Jackpot"> | number
  probabilityPerMillion?: Prisma.IntWithAggregatesFilter<"Jackpot"> | number
  minimumTimeBetweenWinsMinutes?: Prisma.IntWithAggregatesFilter<"Jackpot"> | number
  lastWonAt?: Prisma.DateTimeNullableWithAggregatesFilter<"Jackpot"> | Date | string | null
  lastWonBy?: Prisma.StringNullableWithAggregatesFilter<"Jackpot"> | string | null
  isActive?: Prisma.BoolWithAggregatesFilter<"Jackpot"> | boolean
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Jackpot"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"Jackpot"> | Date | string
}

export type JackpotCreateInput = {
  id?: string
  type: $Enums.JackpotType
  currentAmountCoins?: number
  seedAmountCoins?: number
  minimumBetCoins?: number
  contributionRateBasisPoints?: number
  probabilityPerMillion?: number
  minimumTimeBetweenWinsMinutes?: number
  lastWonAt?: Date | string | null
  isActive?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  contributions?: Prisma.JackpotContributionCreateNestedManyWithoutJackpotInput
  wins?: Prisma.JackpotWinCreateNestedManyWithoutJackpotInput
  lastWinner?: Prisma.UserProfileCreateNestedOneWithoutLastJackpotWonInput
}

export type JackpotUncheckedCreateInput = {
  id?: string
  type: $Enums.JackpotType
  currentAmountCoins?: number
  seedAmountCoins?: number
  minimumBetCoins?: number
  contributionRateBasisPoints?: number
  probabilityPerMillion?: number
  minimumTimeBetweenWinsMinutes?: number
  lastWonAt?: Date | string | null
  lastWonBy?: string | null
  isActive?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  contributions?: Prisma.JackpotContributionUncheckedCreateNestedManyWithoutJackpotInput
  wins?: Prisma.JackpotWinUncheckedCreateNestedManyWithoutJackpotInput
}

export type JackpotUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumJackpotTypeFieldUpdateOperationsInput | $Enums.JackpotType
  currentAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  seedAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  minimumBetCoins?: Prisma.IntFieldUpdateOperationsInput | number
  contributionRateBasisPoints?: Prisma.IntFieldUpdateOperationsInput | number
  probabilityPerMillion?: Prisma.IntFieldUpdateOperationsInput | number
  minimumTimeBetweenWinsMinutes?: Prisma.IntFieldUpdateOperationsInput | number
  lastWonAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  contributions?: Prisma.JackpotContributionUpdateManyWithoutJackpotNestedInput
  wins?: Prisma.JackpotWinUpdateManyWithoutJackpotNestedInput
  lastWinner?: Prisma.UserProfileUpdateOneWithoutLastJackpotWonNestedInput
}

export type JackpotUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumJackpotTypeFieldUpdateOperationsInput | $Enums.JackpotType
  currentAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  seedAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  minimumBetCoins?: Prisma.IntFieldUpdateOperationsInput | number
  contributionRateBasisPoints?: Prisma.IntFieldUpdateOperationsInput | number
  probabilityPerMillion?: Prisma.IntFieldUpdateOperationsInput | number
  minimumTimeBetweenWinsMinutes?: Prisma.IntFieldUpdateOperationsInput | number
  lastWonAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  lastWonBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  contributions?: Prisma.JackpotContributionUncheckedUpdateManyWithoutJackpotNestedInput
  wins?: Prisma.JackpotWinUncheckedUpdateManyWithoutJackpotNestedInput
}

export type JackpotCreateManyInput = {
  id?: string
  type: $Enums.JackpotType
  currentAmountCoins?: number
  seedAmountCoins?: number
  minimumBetCoins?: number
  contributionRateBasisPoints?: number
  probabilityPerMillion?: number
  minimumTimeBetweenWinsMinutes?: number
  lastWonAt?: Date | string | null
  lastWonBy?: string | null
  isActive?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type JackpotUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumJackpotTypeFieldUpdateOperationsInput | $Enums.JackpotType
  currentAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  seedAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  minimumBetCoins?: Prisma.IntFieldUpdateOperationsInput | number
  contributionRateBasisPoints?: Prisma.IntFieldUpdateOperationsInput | number
  probabilityPerMillion?: Prisma.IntFieldUpdateOperationsInput | number
  minimumTimeBetweenWinsMinutes?: Prisma.IntFieldUpdateOperationsInput | number
  lastWonAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type JackpotUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumJackpotTypeFieldUpdateOperationsInput | $Enums.JackpotType
  currentAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  seedAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  minimumBetCoins?: Prisma.IntFieldUpdateOperationsInput | number
  contributionRateBasisPoints?: Prisma.IntFieldUpdateOperationsInput | number
  probabilityPerMillion?: Prisma.IntFieldUpdateOperationsInput | number
  minimumTimeBetweenWinsMinutes?: Prisma.IntFieldUpdateOperationsInput | number
  lastWonAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  lastWonBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type JackpotCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  type?: Prisma.SortOrder
  currentAmountCoins?: Prisma.SortOrder
  seedAmountCoins?: Prisma.SortOrder
  minimumBetCoins?: Prisma.SortOrder
  contributionRateBasisPoints?: Prisma.SortOrder
  probabilityPerMillion?: Prisma.SortOrder
  minimumTimeBetweenWinsMinutes?: Prisma.SortOrder
  lastWonAt?: Prisma.SortOrder
  lastWonBy?: Prisma.SortOrder
  isActive?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type JackpotAvgOrderByAggregateInput = {
  currentAmountCoins?: Prisma.SortOrder
  seedAmountCoins?: Prisma.SortOrder
  minimumBetCoins?: Prisma.SortOrder
  contributionRateBasisPoints?: Prisma.SortOrder
  probabilityPerMillion?: Prisma.SortOrder
  minimumTimeBetweenWinsMinutes?: Prisma.SortOrder
}

export type JackpotMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  type?: Prisma.SortOrder
  currentAmountCoins?: Prisma.SortOrder
  seedAmountCoins?: Prisma.SortOrder
  minimumBetCoins?: Prisma.SortOrder
  contributionRateBasisPoints?: Prisma.SortOrder
  probabilityPerMillion?: Prisma.SortOrder
  minimumTimeBetweenWinsMinutes?: Prisma.SortOrder
  lastWonAt?: Prisma.SortOrder
  lastWonBy?: Prisma.SortOrder
  isActive?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type JackpotMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  type?: Prisma.SortOrder
  currentAmountCoins?: Prisma.SortOrder
  seedAmountCoins?: Prisma.SortOrder
  minimumBetCoins?: Prisma.SortOrder
  contributionRateBasisPoints?: Prisma.SortOrder
  probabilityPerMillion?: Prisma.SortOrder
  minimumTimeBetweenWinsMinutes?: Prisma.SortOrder
  lastWonAt?: Prisma.SortOrder
  lastWonBy?: Prisma.SortOrder
  isActive?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type JackpotSumOrderByAggregateInput = {
  currentAmountCoins?: Prisma.SortOrder
  seedAmountCoins?: Prisma.SortOrder
  minimumBetCoins?: Prisma.SortOrder
  contributionRateBasisPoints?: Prisma.SortOrder
  probabilityPerMillion?: Prisma.SortOrder
  minimumTimeBetweenWinsMinutes?: Prisma.SortOrder
}

export type JackpotScalarRelationFilter = {
  is?: Prisma.JackpotWhereInput
  isNot?: Prisma.JackpotWhereInput
}

export type JackpotListRelationFilter = {
  every?: Prisma.JackpotWhereInput
  some?: Prisma.JackpotWhereInput
  none?: Prisma.JackpotWhereInput
}

export type JackpotOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type EnumJackpotTypeFieldUpdateOperationsInput = {
  set?: $Enums.JackpotType
}

export type JackpotCreateNestedOneWithoutContributionsInput = {
  create?: Prisma.XOR<Prisma.JackpotCreateWithoutContributionsInput, Prisma.JackpotUncheckedCreateWithoutContributionsInput>
  connectOrCreate?: Prisma.JackpotCreateOrConnectWithoutContributionsInput
  connect?: Prisma.JackpotWhereUniqueInput
}

export type JackpotUpdateOneRequiredWithoutContributionsNestedInput = {
  create?: Prisma.XOR<Prisma.JackpotCreateWithoutContributionsInput, Prisma.JackpotUncheckedCreateWithoutContributionsInput>
  connectOrCreate?: Prisma.JackpotCreateOrConnectWithoutContributionsInput
  upsert?: Prisma.JackpotUpsertWithoutContributionsInput
  connect?: Prisma.JackpotWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.JackpotUpdateToOneWithWhereWithoutContributionsInput, Prisma.JackpotUpdateWithoutContributionsInput>, Prisma.JackpotUncheckedUpdateWithoutContributionsInput>
}

export type JackpotCreateNestedOneWithoutWinsInput = {
  create?: Prisma.XOR<Prisma.JackpotCreateWithoutWinsInput, Prisma.JackpotUncheckedCreateWithoutWinsInput>
  connectOrCreate?: Prisma.JackpotCreateOrConnectWithoutWinsInput
  connect?: Prisma.JackpotWhereUniqueInput
}

export type JackpotUpdateOneRequiredWithoutWinsNestedInput = {
  create?: Prisma.XOR<Prisma.JackpotCreateWithoutWinsInput, Prisma.JackpotUncheckedCreateWithoutWinsInput>
  connectOrCreate?: Prisma.JackpotCreateOrConnectWithoutWinsInput
  upsert?: Prisma.JackpotUpsertWithoutWinsInput
  connect?: Prisma.JackpotWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.JackpotUpdateToOneWithWhereWithoutWinsInput, Prisma.JackpotUpdateWithoutWinsInput>, Prisma.JackpotUncheckedUpdateWithoutWinsInput>
}

export type JackpotCreateNestedManyWithoutLastWinnerInput = {
  create?: Prisma.XOR<Prisma.JackpotCreateWithoutLastWinnerInput, Prisma.JackpotUncheckedCreateWithoutLastWinnerInput> | Prisma.JackpotCreateWithoutLastWinnerInput[] | Prisma.JackpotUncheckedCreateWithoutLastWinnerInput[]
  connectOrCreate?: Prisma.JackpotCreateOrConnectWithoutLastWinnerInput | Prisma.JackpotCreateOrConnectWithoutLastWinnerInput[]
  createMany?: Prisma.JackpotCreateManyLastWinnerInputEnvelope
  connect?: Prisma.JackpotWhereUniqueInput | Prisma.JackpotWhereUniqueInput[]
}

export type JackpotUncheckedCreateNestedManyWithoutLastWinnerInput = {
  create?: Prisma.XOR<Prisma.JackpotCreateWithoutLastWinnerInput, Prisma.JackpotUncheckedCreateWithoutLastWinnerInput> | Prisma.JackpotCreateWithoutLastWinnerInput[] | Prisma.JackpotUncheckedCreateWithoutLastWinnerInput[]
  connectOrCreate?: Prisma.JackpotCreateOrConnectWithoutLastWinnerInput | Prisma.JackpotCreateOrConnectWithoutLastWinnerInput[]
  createMany?: Prisma.JackpotCreateManyLastWinnerInputEnvelope
  connect?: Prisma.JackpotWhereUniqueInput | Prisma.JackpotWhereUniqueInput[]
}

export type JackpotUpdateManyWithoutLastWinnerNestedInput = {
  create?: Prisma.XOR<Prisma.JackpotCreateWithoutLastWinnerInput, Prisma.JackpotUncheckedCreateWithoutLastWinnerInput> | Prisma.JackpotCreateWithoutLastWinnerInput[] | Prisma.JackpotUncheckedCreateWithoutLastWinnerInput[]
  connectOrCreate?: Prisma.JackpotCreateOrConnectWithoutLastWinnerInput | Prisma.JackpotCreateOrConnectWithoutLastWinnerInput[]
  upsert?: Prisma.JackpotUpsertWithWhereUniqueWithoutLastWinnerInput | Prisma.JackpotUpsertWithWhereUniqueWithoutLastWinnerInput[]
  createMany?: Prisma.JackpotCreateManyLastWinnerInputEnvelope
  set?: Prisma.JackpotWhereUniqueInput | Prisma.JackpotWhereUniqueInput[]
  disconnect?: Prisma.JackpotWhereUniqueInput | Prisma.JackpotWhereUniqueInput[]
  delete?: Prisma.JackpotWhereUniqueInput | Prisma.JackpotWhereUniqueInput[]
  connect?: Prisma.JackpotWhereUniqueInput | Prisma.JackpotWhereUniqueInput[]
  update?: Prisma.JackpotUpdateWithWhereUniqueWithoutLastWinnerInput | Prisma.JackpotUpdateWithWhereUniqueWithoutLastWinnerInput[]
  updateMany?: Prisma.JackpotUpdateManyWithWhereWithoutLastWinnerInput | Prisma.JackpotUpdateManyWithWhereWithoutLastWinnerInput[]
  deleteMany?: Prisma.JackpotScalarWhereInput | Prisma.JackpotScalarWhereInput[]
}

export type JackpotUncheckedUpdateManyWithoutLastWinnerNestedInput = {
  create?: Prisma.XOR<Prisma.JackpotCreateWithoutLastWinnerInput, Prisma.JackpotUncheckedCreateWithoutLastWinnerInput> | Prisma.JackpotCreateWithoutLastWinnerInput[] | Prisma.JackpotUncheckedCreateWithoutLastWinnerInput[]
  connectOrCreate?: Prisma.JackpotCreateOrConnectWithoutLastWinnerInput | Prisma.JackpotCreateOrConnectWithoutLastWinnerInput[]
  upsert?: Prisma.JackpotUpsertWithWhereUniqueWithoutLastWinnerInput | Prisma.JackpotUpsertWithWhereUniqueWithoutLastWinnerInput[]
  createMany?: Prisma.JackpotCreateManyLastWinnerInputEnvelope
  set?: Prisma.JackpotWhereUniqueInput | Prisma.JackpotWhereUniqueInput[]
  disconnect?: Prisma.JackpotWhereUniqueInput | Prisma.JackpotWhereUniqueInput[]
  delete?: Prisma.JackpotWhereUniqueInput | Prisma.JackpotWhereUniqueInput[]
  connect?: Prisma.JackpotWhereUniqueInput | Prisma.JackpotWhereUniqueInput[]
  update?: Prisma.JackpotUpdateWithWhereUniqueWithoutLastWinnerInput | Prisma.JackpotUpdateWithWhereUniqueWithoutLastWinnerInput[]
  updateMany?: Prisma.JackpotUpdateManyWithWhereWithoutLastWinnerInput | Prisma.JackpotUpdateManyWithWhereWithoutLastWinnerInput[]
  deleteMany?: Prisma.JackpotScalarWhereInput | Prisma.JackpotScalarWhereInput[]
}

export type JackpotCreateWithoutContributionsInput = {
  id?: string
  type: $Enums.JackpotType
  currentAmountCoins?: number
  seedAmountCoins?: number
  minimumBetCoins?: number
  contributionRateBasisPoints?: number
  probabilityPerMillion?: number
  minimumTimeBetweenWinsMinutes?: number
  lastWonAt?: Date | string | null
  isActive?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  wins?: Prisma.JackpotWinCreateNestedManyWithoutJackpotInput
  lastWinner?: Prisma.UserProfileCreateNestedOneWithoutLastJackpotWonInput
}

export type JackpotUncheckedCreateWithoutContributionsInput = {
  id?: string
  type: $Enums.JackpotType
  currentAmountCoins?: number
  seedAmountCoins?: number
  minimumBetCoins?: number
  contributionRateBasisPoints?: number
  probabilityPerMillion?: number
  minimumTimeBetweenWinsMinutes?: number
  lastWonAt?: Date | string | null
  lastWonBy?: string | null
  isActive?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  wins?: Prisma.JackpotWinUncheckedCreateNestedManyWithoutJackpotInput
}

export type JackpotCreateOrConnectWithoutContributionsInput = {
  where: Prisma.JackpotWhereUniqueInput
  create: Prisma.XOR<Prisma.JackpotCreateWithoutContributionsInput, Prisma.JackpotUncheckedCreateWithoutContributionsInput>
}

export type JackpotUpsertWithoutContributionsInput = {
  update: Prisma.XOR<Prisma.JackpotUpdateWithoutContributionsInput, Prisma.JackpotUncheckedUpdateWithoutContributionsInput>
  create: Prisma.XOR<Prisma.JackpotCreateWithoutContributionsInput, Prisma.JackpotUncheckedCreateWithoutContributionsInput>
  where?: Prisma.JackpotWhereInput
}

export type JackpotUpdateToOneWithWhereWithoutContributionsInput = {
  where?: Prisma.JackpotWhereInput
  data: Prisma.XOR<Prisma.JackpotUpdateWithoutContributionsInput, Prisma.JackpotUncheckedUpdateWithoutContributionsInput>
}

export type JackpotUpdateWithoutContributionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumJackpotTypeFieldUpdateOperationsInput | $Enums.JackpotType
  currentAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  seedAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  minimumBetCoins?: Prisma.IntFieldUpdateOperationsInput | number
  contributionRateBasisPoints?: Prisma.IntFieldUpdateOperationsInput | number
  probabilityPerMillion?: Prisma.IntFieldUpdateOperationsInput | number
  minimumTimeBetweenWinsMinutes?: Prisma.IntFieldUpdateOperationsInput | number
  lastWonAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  wins?: Prisma.JackpotWinUpdateManyWithoutJackpotNestedInput
  lastWinner?: Prisma.UserProfileUpdateOneWithoutLastJackpotWonNestedInput
}

export type JackpotUncheckedUpdateWithoutContributionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumJackpotTypeFieldUpdateOperationsInput | $Enums.JackpotType
  currentAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  seedAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  minimumBetCoins?: Prisma.IntFieldUpdateOperationsInput | number
  contributionRateBasisPoints?: Prisma.IntFieldUpdateOperationsInput | number
  probabilityPerMillion?: Prisma.IntFieldUpdateOperationsInput | number
  minimumTimeBetweenWinsMinutes?: Prisma.IntFieldUpdateOperationsInput | number
  lastWonAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  lastWonBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  wins?: Prisma.JackpotWinUncheckedUpdateManyWithoutJackpotNestedInput
}

export type JackpotCreateWithoutWinsInput = {
  id?: string
  type: $Enums.JackpotType
  currentAmountCoins?: number
  seedAmountCoins?: number
  minimumBetCoins?: number
  contributionRateBasisPoints?: number
  probabilityPerMillion?: number
  minimumTimeBetweenWinsMinutes?: number
  lastWonAt?: Date | string | null
  isActive?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  contributions?: Prisma.JackpotContributionCreateNestedManyWithoutJackpotInput
  lastWinner?: Prisma.UserProfileCreateNestedOneWithoutLastJackpotWonInput
}

export type JackpotUncheckedCreateWithoutWinsInput = {
  id?: string
  type: $Enums.JackpotType
  currentAmountCoins?: number
  seedAmountCoins?: number
  minimumBetCoins?: number
  contributionRateBasisPoints?: number
  probabilityPerMillion?: number
  minimumTimeBetweenWinsMinutes?: number
  lastWonAt?: Date | string | null
  lastWonBy?: string | null
  isActive?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  contributions?: Prisma.JackpotContributionUncheckedCreateNestedManyWithoutJackpotInput
}

export type JackpotCreateOrConnectWithoutWinsInput = {
  where: Prisma.JackpotWhereUniqueInput
  create: Prisma.XOR<Prisma.JackpotCreateWithoutWinsInput, Prisma.JackpotUncheckedCreateWithoutWinsInput>
}

export type JackpotUpsertWithoutWinsInput = {
  update: Prisma.XOR<Prisma.JackpotUpdateWithoutWinsInput, Prisma.JackpotUncheckedUpdateWithoutWinsInput>
  create: Prisma.XOR<Prisma.JackpotCreateWithoutWinsInput, Prisma.JackpotUncheckedCreateWithoutWinsInput>
  where?: Prisma.JackpotWhereInput
}

export type JackpotUpdateToOneWithWhereWithoutWinsInput = {
  where?: Prisma.JackpotWhereInput
  data: Prisma.XOR<Prisma.JackpotUpdateWithoutWinsInput, Prisma.JackpotUncheckedUpdateWithoutWinsInput>
}

export type JackpotUpdateWithoutWinsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumJackpotTypeFieldUpdateOperationsInput | $Enums.JackpotType
  currentAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  seedAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  minimumBetCoins?: Prisma.IntFieldUpdateOperationsInput | number
  contributionRateBasisPoints?: Prisma.IntFieldUpdateOperationsInput | number
  probabilityPerMillion?: Prisma.IntFieldUpdateOperationsInput | number
  minimumTimeBetweenWinsMinutes?: Prisma.IntFieldUpdateOperationsInput | number
  lastWonAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  contributions?: Prisma.JackpotContributionUpdateManyWithoutJackpotNestedInput
  lastWinner?: Prisma.UserProfileUpdateOneWithoutLastJackpotWonNestedInput
}

export type JackpotUncheckedUpdateWithoutWinsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumJackpotTypeFieldUpdateOperationsInput | $Enums.JackpotType
  currentAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  seedAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  minimumBetCoins?: Prisma.IntFieldUpdateOperationsInput | number
  contributionRateBasisPoints?: Prisma.IntFieldUpdateOperationsInput | number
  probabilityPerMillion?: Prisma.IntFieldUpdateOperationsInput | number
  minimumTimeBetweenWinsMinutes?: Prisma.IntFieldUpdateOperationsInput | number
  lastWonAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  lastWonBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  contributions?: Prisma.JackpotContributionUncheckedUpdateManyWithoutJackpotNestedInput
}

export type JackpotCreateWithoutLastWinnerInput = {
  id?: string
  type: $Enums.JackpotType
  currentAmountCoins?: number
  seedAmountCoins?: number
  minimumBetCoins?: number
  contributionRateBasisPoints?: number
  probabilityPerMillion?: number
  minimumTimeBetweenWinsMinutes?: number
  lastWonAt?: Date | string | null
  isActive?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  contributions?: Prisma.JackpotContributionCreateNestedManyWithoutJackpotInput
  wins?: Prisma.JackpotWinCreateNestedManyWithoutJackpotInput
}

export type JackpotUncheckedCreateWithoutLastWinnerInput = {
  id?: string
  type: $Enums.JackpotType
  currentAmountCoins?: number
  seedAmountCoins?: number
  minimumBetCoins?: number
  contributionRateBasisPoints?: number
  probabilityPerMillion?: number
  minimumTimeBetweenWinsMinutes?: number
  lastWonAt?: Date | string | null
  isActive?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  contributions?: Prisma.JackpotContributionUncheckedCreateNestedManyWithoutJackpotInput
  wins?: Prisma.JackpotWinUncheckedCreateNestedManyWithoutJackpotInput
}

export type JackpotCreateOrConnectWithoutLastWinnerInput = {
  where: Prisma.JackpotWhereUniqueInput
  create: Prisma.XOR<Prisma.JackpotCreateWithoutLastWinnerInput, Prisma.JackpotUncheckedCreateWithoutLastWinnerInput>
}

export type JackpotCreateManyLastWinnerInputEnvelope = {
  data: Prisma.JackpotCreateManyLastWinnerInput | Prisma.JackpotCreateManyLastWinnerInput[]
  skipDuplicates?: boolean
}

export type JackpotUpsertWithWhereUniqueWithoutLastWinnerInput = {
  where: Prisma.JackpotWhereUniqueInput
  update: Prisma.XOR<Prisma.JackpotUpdateWithoutLastWinnerInput, Prisma.JackpotUncheckedUpdateWithoutLastWinnerInput>
  create: Prisma.XOR<Prisma.JackpotCreateWithoutLastWinnerInput, Prisma.JackpotUncheckedCreateWithoutLastWinnerInput>
}

export type JackpotUpdateWithWhereUniqueWithoutLastWinnerInput = {
  where: Prisma.JackpotWhereUniqueInput
  data: Prisma.XOR<Prisma.JackpotUpdateWithoutLastWinnerInput, Prisma.JackpotUncheckedUpdateWithoutLastWinnerInput>
}

export type JackpotUpdateManyWithWhereWithoutLastWinnerInput = {
  where: Prisma.JackpotScalarWhereInput
  data: Prisma.XOR<Prisma.JackpotUpdateManyMutationInput, Prisma.JackpotUncheckedUpdateManyWithoutLastWinnerInput>
}

export type JackpotScalarWhereInput = {
  AND?: Prisma.JackpotScalarWhereInput | Prisma.JackpotScalarWhereInput[]
  OR?: Prisma.JackpotScalarWhereInput[]
  NOT?: Prisma.JackpotScalarWhereInput | Prisma.JackpotScalarWhereInput[]
  id?: Prisma.StringFilter<"Jackpot"> | string
  type?: Prisma.EnumJackpotTypeFilter<"Jackpot"> | $Enums.JackpotType
  currentAmountCoins?: Prisma.IntFilter<"Jackpot"> | number
  seedAmountCoins?: Prisma.IntFilter<"Jackpot"> | number
  minimumBetCoins?: Prisma.IntFilter<"Jackpot"> | number
  contributionRateBasisPoints?: Prisma.IntFilter<"Jackpot"> | number
  probabilityPerMillion?: Prisma.IntFilter<"Jackpot"> | number
  minimumTimeBetweenWinsMinutes?: Prisma.IntFilter<"Jackpot"> | number
  lastWonAt?: Prisma.DateTimeNullableFilter<"Jackpot"> | Date | string | null
  lastWonBy?: Prisma.StringNullableFilter<"Jackpot"> | string | null
  isActive?: Prisma.BoolFilter<"Jackpot"> | boolean
  createdAt?: Prisma.DateTimeFilter<"Jackpot"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Jackpot"> | Date | string
}

export type JackpotCreateManyLastWinnerInput = {
  id?: string
  type: $Enums.JackpotType
  currentAmountCoins?: number
  seedAmountCoins?: number
  minimumBetCoins?: number
  contributionRateBasisPoints?: number
  probabilityPerMillion?: number
  minimumTimeBetweenWinsMinutes?: number
  lastWonAt?: Date | string | null
  isActive?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type JackpotUpdateWithoutLastWinnerInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumJackpotTypeFieldUpdateOperationsInput | $Enums.JackpotType
  currentAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  seedAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  minimumBetCoins?: Prisma.IntFieldUpdateOperationsInput | number
  contributionRateBasisPoints?: Prisma.IntFieldUpdateOperationsInput | number
  probabilityPerMillion?: Prisma.IntFieldUpdateOperationsInput | number
  minimumTimeBetweenWinsMinutes?: Prisma.IntFieldUpdateOperationsInput | number
  lastWonAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  contributions?: Prisma.JackpotContributionUpdateManyWithoutJackpotNestedInput
  wins?: Prisma.JackpotWinUpdateManyWithoutJackpotNestedInput
}

export type JackpotUncheckedUpdateWithoutLastWinnerInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumJackpotTypeFieldUpdateOperationsInput | $Enums.JackpotType
  currentAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  seedAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  minimumBetCoins?: Prisma.IntFieldUpdateOperationsInput | number
  contributionRateBasisPoints?: Prisma.IntFieldUpdateOperationsInput | number
  probabilityPerMillion?: Prisma.IntFieldUpdateOperationsInput | number
  minimumTimeBetweenWinsMinutes?: Prisma.IntFieldUpdateOperationsInput | number
  lastWonAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  contributions?: Prisma.JackpotContributionUncheckedUpdateManyWithoutJackpotNestedInput
  wins?: Prisma.JackpotWinUncheckedUpdateManyWithoutJackpotNestedInput
}

export type JackpotUncheckedUpdateManyWithoutLastWinnerInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumJackpotTypeFieldUpdateOperationsInput | $Enums.JackpotType
  currentAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  seedAmountCoins?: Prisma.IntFieldUpdateOperationsInput | number
  minimumBetCoins?: Prisma.IntFieldUpdateOperationsInput | number
  contributionRateBasisPoints?: Prisma.IntFieldUpdateOperationsInput | number
  probabilityPerMillion?: Prisma.IntFieldUpdateOperationsInput | number
  minimumTimeBetweenWinsMinutes?: Prisma.IntFieldUpdateOperationsInput | number
  lastWonAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}


/**
 * Count Type JackpotCountOutputType
 */

export type JackpotCountOutputType = {
  contributions: number
  wins: number
}

export type JackpotCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  contributions?: boolean | JackpotCountOutputTypeCountContributionsArgs
  wins?: boolean | JackpotCountOutputTypeCountWinsArgs
}

/**
 * JackpotCountOutputType without action
 */
export type JackpotCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the JackpotCountOutputType
   */
  select?: Prisma.JackpotCountOutputTypeSelect<ExtArgs> | null
}

/**
 * JackpotCountOutputType without action
 */
export type JackpotCountOutputTypeCountContributionsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.JackpotContributionWhereInput
}

/**
 * JackpotCountOutputType without action
 */
export type JackpotCountOutputTypeCountWinsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.JackpotWinWhereInput
}


export type JackpotSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  type?: boolean
  currentAmountCoins?: boolean
  seedAmountCoins?: boolean
  minimumBetCoins?: boolean
  contributionRateBasisPoints?: boolean
  probabilityPerMillion?: boolean
  minimumTimeBetweenWinsMinutes?: boolean
  lastWonAt?: boolean
  lastWonBy?: boolean
  isActive?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  contributions?: boolean | Prisma.Jackpot$contributionsArgs<ExtArgs>
  wins?: boolean | Prisma.Jackpot$winsArgs<ExtArgs>
  lastWinner?: boolean | Prisma.Jackpot$lastWinnerArgs<ExtArgs>
  _count?: boolean | Prisma.JackpotCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["jackpot"]>

export type JackpotSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  type?: boolean
  currentAmountCoins?: boolean
  seedAmountCoins?: boolean
  minimumBetCoins?: boolean
  contributionRateBasisPoints?: boolean
  probabilityPerMillion?: boolean
  minimumTimeBetweenWinsMinutes?: boolean
  lastWonAt?: boolean
  lastWonBy?: boolean
  isActive?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  lastWinner?: boolean | Prisma.Jackpot$lastWinnerArgs<ExtArgs>
}, ExtArgs["result"]["jackpot"]>

export type JackpotSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  type?: boolean
  currentAmountCoins?: boolean
  seedAmountCoins?: boolean
  minimumBetCoins?: boolean
  contributionRateBasisPoints?: boolean
  probabilityPerMillion?: boolean
  minimumTimeBetweenWinsMinutes?: boolean
  lastWonAt?: boolean
  lastWonBy?: boolean
  isActive?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  lastWinner?: boolean | Prisma.Jackpot$lastWinnerArgs<ExtArgs>
}, ExtArgs["result"]["jackpot"]>

export type JackpotSelectScalar = {
  id?: boolean
  type?: boolean
  currentAmountCoins?: boolean
  seedAmountCoins?: boolean
  minimumBetCoins?: boolean
  contributionRateBasisPoints?: boolean
  probabilityPerMillion?: boolean
  minimumTimeBetweenWinsMinutes?: boolean
  lastWonAt?: boolean
  lastWonBy?: boolean
  isActive?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type JackpotOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "type" | "currentAmountCoins" | "seedAmountCoins" | "minimumBetCoins" | "contributionRateBasisPoints" | "probabilityPerMillion" | "minimumTimeBetweenWinsMinutes" | "lastWonAt" | "lastWonBy" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["jackpot"]>
export type JackpotInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  contributions?: boolean | Prisma.Jackpot$contributionsArgs<ExtArgs>
  wins?: boolean | Prisma.Jackpot$winsArgs<ExtArgs>
  lastWinner?: boolean | Prisma.Jackpot$lastWinnerArgs<ExtArgs>
  _count?: boolean | Prisma.JackpotCountOutputTypeDefaultArgs<ExtArgs>
}
export type JackpotIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  lastWinner?: boolean | Prisma.Jackpot$lastWinnerArgs<ExtArgs>
}
export type JackpotIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  lastWinner?: boolean | Prisma.Jackpot$lastWinnerArgs<ExtArgs>
}

export type $JackpotPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Jackpot"
  objects: {
    contributions: Prisma.$JackpotContributionPayload<ExtArgs>[]
    wins: Prisma.$JackpotWinPayload<ExtArgs>[]
    lastWinner: Prisma.$UserProfilePayload<ExtArgs> | null
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    type: $Enums.JackpotType
    currentAmountCoins: number
    seedAmountCoins: number
    minimumBetCoins: number
    contributionRateBasisPoints: number
    probabilityPerMillion: number
    minimumTimeBetweenWinsMinutes: number
    lastWonAt: Date | null
    lastWonBy: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["jackpot"]>
  composites: {}
}

export type JackpotGetPayload<S extends boolean | null | undefined | JackpotDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$JackpotPayload, S>

export type JackpotCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<JackpotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: JackpotCountAggregateInputType | true
  }

export interface JackpotDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Jackpot'], meta: { name: 'Jackpot' } }
  /**
   * Find zero or one Jackpot that matches the filter.
   * @param {JackpotFindUniqueArgs} args - Arguments to find a Jackpot
   * @example
   * // Get one Jackpot
   * const jackpot = await prisma.jackpot.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends JackpotFindUniqueArgs>(args: Prisma.SelectSubset<T, JackpotFindUniqueArgs<ExtArgs>>): Prisma.Prisma__JackpotClient<runtime.Types.Result.GetResult<Prisma.$JackpotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Jackpot that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {JackpotFindUniqueOrThrowArgs} args - Arguments to find a Jackpot
   * @example
   * // Get one Jackpot
   * const jackpot = await prisma.jackpot.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends JackpotFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, JackpotFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__JackpotClient<runtime.Types.Result.GetResult<Prisma.$JackpotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Jackpot that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {JackpotFindFirstArgs} args - Arguments to find a Jackpot
   * @example
   * // Get one Jackpot
   * const jackpot = await prisma.jackpot.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends JackpotFindFirstArgs>(args?: Prisma.SelectSubset<T, JackpotFindFirstArgs<ExtArgs>>): Prisma.Prisma__JackpotClient<runtime.Types.Result.GetResult<Prisma.$JackpotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Jackpot that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {JackpotFindFirstOrThrowArgs} args - Arguments to find a Jackpot
   * @example
   * // Get one Jackpot
   * const jackpot = await prisma.jackpot.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends JackpotFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, JackpotFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__JackpotClient<runtime.Types.Result.GetResult<Prisma.$JackpotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Jackpots that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {JackpotFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Jackpots
   * const jackpots = await prisma.jackpot.findMany()
   * 
   * // Get first 10 Jackpots
   * const jackpots = await prisma.jackpot.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const jackpotWithIdOnly = await prisma.jackpot.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends JackpotFindManyArgs>(args?: Prisma.SelectSubset<T, JackpotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$JackpotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Jackpot.
   * @param {JackpotCreateArgs} args - Arguments to create a Jackpot.
   * @example
   * // Create one Jackpot
   * const Jackpot = await prisma.jackpot.create({
   *   data: {
   *     // ... data to create a Jackpot
   *   }
   * })
   * 
   */
  create<T extends JackpotCreateArgs>(args: Prisma.SelectSubset<T, JackpotCreateArgs<ExtArgs>>): Prisma.Prisma__JackpotClient<runtime.Types.Result.GetResult<Prisma.$JackpotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Jackpots.
   * @param {JackpotCreateManyArgs} args - Arguments to create many Jackpots.
   * @example
   * // Create many Jackpots
   * const jackpot = await prisma.jackpot.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends JackpotCreateManyArgs>(args?: Prisma.SelectSubset<T, JackpotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Jackpots and returns the data saved in the database.
   * @param {JackpotCreateManyAndReturnArgs} args - Arguments to create many Jackpots.
   * @example
   * // Create many Jackpots
   * const jackpot = await prisma.jackpot.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Jackpots and only return the `id`
   * const jackpotWithIdOnly = await prisma.jackpot.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends JackpotCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, JackpotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$JackpotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a Jackpot.
   * @param {JackpotDeleteArgs} args - Arguments to delete one Jackpot.
   * @example
   * // Delete one Jackpot
   * const Jackpot = await prisma.jackpot.delete({
   *   where: {
   *     // ... filter to delete one Jackpot
   *   }
   * })
   * 
   */
  delete<T extends JackpotDeleteArgs>(args: Prisma.SelectSubset<T, JackpotDeleteArgs<ExtArgs>>): Prisma.Prisma__JackpotClient<runtime.Types.Result.GetResult<Prisma.$JackpotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Jackpot.
   * @param {JackpotUpdateArgs} args - Arguments to update one Jackpot.
   * @example
   * // Update one Jackpot
   * const jackpot = await prisma.jackpot.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends JackpotUpdateArgs>(args: Prisma.SelectSubset<T, JackpotUpdateArgs<ExtArgs>>): Prisma.Prisma__JackpotClient<runtime.Types.Result.GetResult<Prisma.$JackpotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Jackpots.
   * @param {JackpotDeleteManyArgs} args - Arguments to filter Jackpots to delete.
   * @example
   * // Delete a few Jackpots
   * const { count } = await prisma.jackpot.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends JackpotDeleteManyArgs>(args?: Prisma.SelectSubset<T, JackpotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Jackpots.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {JackpotUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Jackpots
   * const jackpot = await prisma.jackpot.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends JackpotUpdateManyArgs>(args: Prisma.SelectSubset<T, JackpotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Jackpots and returns the data updated in the database.
   * @param {JackpotUpdateManyAndReturnArgs} args - Arguments to update many Jackpots.
   * @example
   * // Update many Jackpots
   * const jackpot = await prisma.jackpot.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Jackpots and only return the `id`
   * const jackpotWithIdOnly = await prisma.jackpot.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends JackpotUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, JackpotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$JackpotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one Jackpot.
   * @param {JackpotUpsertArgs} args - Arguments to update or create a Jackpot.
   * @example
   * // Update or create a Jackpot
   * const jackpot = await prisma.jackpot.upsert({
   *   create: {
   *     // ... data to create a Jackpot
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Jackpot we want to update
   *   }
   * })
   */
  upsert<T extends JackpotUpsertArgs>(args: Prisma.SelectSubset<T, JackpotUpsertArgs<ExtArgs>>): Prisma.Prisma__JackpotClient<runtime.Types.Result.GetResult<Prisma.$JackpotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Jackpots.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {JackpotCountArgs} args - Arguments to filter Jackpots to count.
   * @example
   * // Count the number of Jackpots
   * const count = await prisma.jackpot.count({
   *   where: {
   *     // ... the filter for the Jackpots we want to count
   *   }
   * })
  **/
  count<T extends JackpotCountArgs>(
    args?: Prisma.Subset<T, JackpotCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], JackpotCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Jackpot.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {JackpotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends JackpotAggregateArgs>(args: Prisma.Subset<T, JackpotAggregateArgs>): Prisma.PrismaPromise<GetJackpotAggregateType<T>>

  /**
   * Group by Jackpot.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {JackpotGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends JackpotGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: JackpotGroupByArgs['orderBy'] }
      : { orderBy?: JackpotGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, JackpotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJackpotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Jackpot model
 */
readonly fields: JackpotFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Jackpot.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__JackpotClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  contributions<T extends Prisma.Jackpot$contributionsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Jackpot$contributionsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$JackpotContributionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  wins<T extends Prisma.Jackpot$winsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Jackpot$winsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$JackpotWinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  lastWinner<T extends Prisma.Jackpot$lastWinnerArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Jackpot$lastWinnerArgs<ExtArgs>>): Prisma.Prisma__UserProfileClient<runtime.Types.Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Jackpot model
 */
export interface JackpotFieldRefs {
  readonly id: Prisma.FieldRef<"Jackpot", 'String'>
  readonly type: Prisma.FieldRef<"Jackpot", 'JackpotType'>
  readonly currentAmountCoins: Prisma.FieldRef<"Jackpot", 'Int'>
  readonly seedAmountCoins: Prisma.FieldRef<"Jackpot", 'Int'>
  readonly minimumBetCoins: Prisma.FieldRef<"Jackpot", 'Int'>
  readonly contributionRateBasisPoints: Prisma.FieldRef<"Jackpot", 'Int'>
  readonly probabilityPerMillion: Prisma.FieldRef<"Jackpot", 'Int'>
  readonly minimumTimeBetweenWinsMinutes: Prisma.FieldRef<"Jackpot", 'Int'>
  readonly lastWonAt: Prisma.FieldRef<"Jackpot", 'DateTime'>
  readonly lastWonBy: Prisma.FieldRef<"Jackpot", 'String'>
  readonly isActive: Prisma.FieldRef<"Jackpot", 'Boolean'>
  readonly createdAt: Prisma.FieldRef<"Jackpot", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"Jackpot", 'DateTime'>
}
    

// Custom InputTypes
/**
 * Jackpot findUnique
 */
export type JackpotFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Jackpot
   */
  select?: Prisma.JackpotSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Jackpot
   */
  omit?: Prisma.JackpotOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.JackpotInclude<ExtArgs> | null
  /**
   * Filter, which Jackpot to fetch.
   */
  where: Prisma.JackpotWhereUniqueInput
}

/**
 * Jackpot findUniqueOrThrow
 */
export type JackpotFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Jackpot
   */
  select?: Prisma.JackpotSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Jackpot
   */
  omit?: Prisma.JackpotOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.JackpotInclude<ExtArgs> | null
  /**
   * Filter, which Jackpot to fetch.
   */
  where: Prisma.JackpotWhereUniqueInput
}

/**
 * Jackpot findFirst
 */
export type JackpotFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Jackpot
   */
  select?: Prisma.JackpotSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Jackpot
   */
  omit?: Prisma.JackpotOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.JackpotInclude<ExtArgs> | null
  /**
   * Filter, which Jackpot to fetch.
   */
  where?: Prisma.JackpotWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Jackpots to fetch.
   */
  orderBy?: Prisma.JackpotOrderByWithRelationInput | Prisma.JackpotOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Jackpots.
   */
  cursor?: Prisma.JackpotWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Jackpots from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Jackpots.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Jackpots.
   */
  distinct?: Prisma.JackpotScalarFieldEnum | Prisma.JackpotScalarFieldEnum[]
}

/**
 * Jackpot findFirstOrThrow
 */
export type JackpotFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Jackpot
   */
  select?: Prisma.JackpotSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Jackpot
   */
  omit?: Prisma.JackpotOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.JackpotInclude<ExtArgs> | null
  /**
   * Filter, which Jackpot to fetch.
   */
  where?: Prisma.JackpotWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Jackpots to fetch.
   */
  orderBy?: Prisma.JackpotOrderByWithRelationInput | Prisma.JackpotOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Jackpots.
   */
  cursor?: Prisma.JackpotWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Jackpots from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Jackpots.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Jackpots.
   */
  distinct?: Prisma.JackpotScalarFieldEnum | Prisma.JackpotScalarFieldEnum[]
}

/**
 * Jackpot findMany
 */
export type JackpotFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Jackpot
   */
  select?: Prisma.JackpotSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Jackpot
   */
  omit?: Prisma.JackpotOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.JackpotInclude<ExtArgs> | null
  /**
   * Filter, which Jackpots to fetch.
   */
  where?: Prisma.JackpotWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Jackpots to fetch.
   */
  orderBy?: Prisma.JackpotOrderByWithRelationInput | Prisma.JackpotOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Jackpots.
   */
  cursor?: Prisma.JackpotWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Jackpots from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Jackpots.
   */
  skip?: number
  distinct?: Prisma.JackpotScalarFieldEnum | Prisma.JackpotScalarFieldEnum[]
}

/**
 * Jackpot create
 */
export type JackpotCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Jackpot
   */
  select?: Prisma.JackpotSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Jackpot
   */
  omit?: Prisma.JackpotOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.JackpotInclude<ExtArgs> | null
  /**
   * The data needed to create a Jackpot.
   */
  data: Prisma.XOR<Prisma.JackpotCreateInput, Prisma.JackpotUncheckedCreateInput>
}

/**
 * Jackpot createMany
 */
export type JackpotCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Jackpots.
   */
  data: Prisma.JackpotCreateManyInput | Prisma.JackpotCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Jackpot createManyAndReturn
 */
export type JackpotCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Jackpot
   */
  select?: Prisma.JackpotSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Jackpot
   */
  omit?: Prisma.JackpotOmit<ExtArgs> | null
  /**
   * The data used to create many Jackpots.
   */
  data: Prisma.JackpotCreateManyInput | Prisma.JackpotCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.JackpotIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * Jackpot update
 */
export type JackpotUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Jackpot
   */
  select?: Prisma.JackpotSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Jackpot
   */
  omit?: Prisma.JackpotOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.JackpotInclude<ExtArgs> | null
  /**
   * The data needed to update a Jackpot.
   */
  data: Prisma.XOR<Prisma.JackpotUpdateInput, Prisma.JackpotUncheckedUpdateInput>
  /**
   * Choose, which Jackpot to update.
   */
  where: Prisma.JackpotWhereUniqueInput
}

/**
 * Jackpot updateMany
 */
export type JackpotUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Jackpots.
   */
  data: Prisma.XOR<Prisma.JackpotUpdateManyMutationInput, Prisma.JackpotUncheckedUpdateManyInput>
  /**
   * Filter which Jackpots to update
   */
  where?: Prisma.JackpotWhereInput
  /**
   * Limit how many Jackpots to update.
   */
  limit?: number
}

/**
 * Jackpot updateManyAndReturn
 */
export type JackpotUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Jackpot
   */
  select?: Prisma.JackpotSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Jackpot
   */
  omit?: Prisma.JackpotOmit<ExtArgs> | null
  /**
   * The data used to update Jackpots.
   */
  data: Prisma.XOR<Prisma.JackpotUpdateManyMutationInput, Prisma.JackpotUncheckedUpdateManyInput>
  /**
   * Filter which Jackpots to update
   */
  where?: Prisma.JackpotWhereInput
  /**
   * Limit how many Jackpots to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.JackpotIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * Jackpot upsert
 */
export type JackpotUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Jackpot
   */
  select?: Prisma.JackpotSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Jackpot
   */
  omit?: Prisma.JackpotOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.JackpotInclude<ExtArgs> | null
  /**
   * The filter to search for the Jackpot to update in case it exists.
   */
  where: Prisma.JackpotWhereUniqueInput
  /**
   * In case the Jackpot found by the `where` argument doesn't exist, create a new Jackpot with this data.
   */
  create: Prisma.XOR<Prisma.JackpotCreateInput, Prisma.JackpotUncheckedCreateInput>
  /**
   * In case the Jackpot was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.JackpotUpdateInput, Prisma.JackpotUncheckedUpdateInput>
}

/**
 * Jackpot delete
 */
export type JackpotDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Jackpot
   */
  select?: Prisma.JackpotSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Jackpot
   */
  omit?: Prisma.JackpotOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.JackpotInclude<ExtArgs> | null
  /**
   * Filter which Jackpot to delete.
   */
  where: Prisma.JackpotWhereUniqueInput
}

/**
 * Jackpot deleteMany
 */
export type JackpotDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Jackpots to delete
   */
  where?: Prisma.JackpotWhereInput
  /**
   * Limit how many Jackpots to delete.
   */
  limit?: number
}

/**
 * Jackpot.contributions
 */
export type Jackpot$contributionsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the JackpotContribution
   */
  select?: Prisma.JackpotContributionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the JackpotContribution
   */
  omit?: Prisma.JackpotContributionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.JackpotContributionInclude<ExtArgs> | null
  where?: Prisma.JackpotContributionWhereInput
  orderBy?: Prisma.JackpotContributionOrderByWithRelationInput | Prisma.JackpotContributionOrderByWithRelationInput[]
  cursor?: Prisma.JackpotContributionWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.JackpotContributionScalarFieldEnum | Prisma.JackpotContributionScalarFieldEnum[]
}

/**
 * Jackpot.wins
 */
export type Jackpot$winsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the JackpotWin
   */
  select?: Prisma.JackpotWinSelect<ExtArgs> | null
  /**
   * Omit specific fields from the JackpotWin
   */
  omit?: Prisma.JackpotWinOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.JackpotWinInclude<ExtArgs> | null
  where?: Prisma.JackpotWinWhereInput
  orderBy?: Prisma.JackpotWinOrderByWithRelationInput | Prisma.JackpotWinOrderByWithRelationInput[]
  cursor?: Prisma.JackpotWinWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.JackpotWinScalarFieldEnum | Prisma.JackpotWinScalarFieldEnum[]
}

/**
 * Jackpot.lastWinner
 */
export type Jackpot$lastWinnerArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserProfile
   */
  select?: Prisma.UserProfileSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserProfile
   */
  omit?: Prisma.UserProfileOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserProfileInclude<ExtArgs> | null
  where?: Prisma.UserProfileWhereInput
}

/**
 * Jackpot without action
 */
export type JackpotDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Jackpot
   */
  select?: Prisma.JackpotSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Jackpot
   */
  omit?: Prisma.JackpotOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.JackpotInclude<ExtArgs> | null
}
