// File: ai/client/src/stores/user.store.ts
import { computed, type Ref, ref } from 'vue' // ref might still be needed for some local non-colada state
import { defineStore } from 'pinia'
import { useQuery, useMutation, useQueryCache } from '@pinia/colada' // Correct import
import type {
  PaginatedResponse,
  SetReferrerDto,
  UpdateUserInput,
  PrismaUserProfile as SharedUserProfileType,
} from 'shared/dist'
import { useAuthStore } from './auth.store'
import { orpcManager } from '@/utils/orpc.client'

// Define specific, simpler response types from server (as established before)
type UserProfileBasicUpdateResponse = Pick<
  SharedUserProfileType,
  'id' | 'username' | 'avatar' | 'userId'
>
type UserProfileAvatarUpdateResponse = Pick<SharedUserProfileType, 'id' | 'avatar' | 'userId'>
type UserProfileCashtagUpdateResponse = Pick<SharedUserProfileType, 'id' | 'cashtag' | 'userId'>
type ReferredUserProfileSubset = Pick<
  SharedUserProfileType,
  'id' | 'username' | 'avatar' | 'createdAt' | 'userId'
>
type LeaderboardUserSubset = Pick<
  SharedUserProfileType,
  'id' | 'username' | 'avatar' | 'totalXpFromOperator'
>

export const useUserStore = defineStore('user', () => {
  const authStore = useAuthStore()
  const orpcClient = orpcManager.getColadaClient() // This is the raw oRPC client Colada will use
  const queryCache = useQueryCache()

  // --- Define Reactive Procedures using createQuery and createMutation ---

  const _updateUserProfile = useMutation({
    mutation: (payload: UpdateUserInput) =>
      orpcClient.user.updateProfile.call(payload) as Promise<UserProfileBasicUpdateResponse>,
    onSuccess: (data, variables, context) => {
      if (authStore.currentUser && data) {
        authStore.currentUser = { ...authStore.currentUser, ...data }
      }
      queryCache.invalidateQueries({ key: [['user', 'getCurrentUser']] })
      // Potentially invalidate other relevant queries
    },
    // onMutate: for optimistic updates (see below)
    // onError: for error handling / rollback
  })

  const _updateUserAvatar = useMutation({
    mutation: (payload: { avatarUrl: string }) =>
      orpcClient.user.updateAvatar.call(payload) as Promise<UserProfileAvatarUpdateResponse>,
    onSuccess: (data) => {
      if (authStore.currentUser && data) {
        authStore.currentUser.avatar = data.avatar
      }
      queryCache.invalidateQueries({ key: [['user', 'getCurrentUser']] })
    },
  })

  const _updateUserCashtag = useMutation({
    mutation: (payload: { cashtag: string }) =>
      orpcClient.user.updateCashtag.call(payload) as Promise<UserProfileCashtagUpdateResponse>,
    onSuccess: (data) => {
      if (authStore.currentUser && data) {
        authStore.currentUser.cashtag = data.cashtag
      }
      queryCache.invalidateQueries({ key: [['user', 'getCurrentUser']] })
    },
  })

  const _setReferrer = useMutation({
    mutation: (payload: SetReferrerDto) =>
      orpcClient.user.setReferrer.call(payload) as Promise<{ success: boolean; message: string }>,

    // onSuccess: () => { /* Maybe show notification */ }
  })

  // For getMyReferrals - a query
  // The key can be static if it takes no parameters for fetching
  const _getMyReferrals = useQuery({
    key: () => [['user', 'getMyReferrals']], // Static key for this example
    query: () =>
      orpcClient.user.getMyReferrals.call() as Promise<ReferredUserProfileSubset[] | null>,
    enabled: computed(() => authStore.isAuthenticated), // Example: only enable when authenticated
    // staleTime: 5 * 60 * 1000, // 5 minutes
  })

  // For getLeaderboard - a paginated query
  // Key needs to be dynamic based on page & limit.
  // We define it to accept reactive refs for page and limit, or pass them to `fetch` method.
  // @pinia/colada often uses the parameters passed to queryFn or a separate `variables` ref for dynamic keys.
  // For simplicity, let's assume queryFn receives params and Colada handles caching based on these.
  // Alternatively, the `key` itself can be a function that returns an array including reactive page/limit.
  // const _getLeaderboardx = createQuery({
  //   // Key will be generated by Colada based on procedure path and queryFn parameters
  //   queryFn: (params: { page: number; limit: number }) =>
  //     orpcClient.user.getLeaderboard.call(
  //       params
  //     ) as Promise<PaginatedResponse<LeaderboardUserSubset> | null>,
  //   // enabled: false, // Typically fetch on demand for paginated data
  // })
  const _getLeaderboard = useQuery({
    key: () => ['contacts'],
    query: async (context: any) => {
      const { page, limit } = context
      return orpcClient.user.getLeaderboard.call({
        page,
        limit,
      }) as Promise<PaginatedResponse<LeaderboardUserSubset> | null>
    },
  })
  // --- Actions (now mostly trigger mutations or manage query parameters) ---

  async function updateUserProfile(
    payload: UpdateUserInput
  ): Promise<{ success: boolean; user?: UserProfileBasicUpdateResponse; error?: any }> {
    try {
      const result = await _updateUserProfile.mutateAsync(payload)
      return { success: true, user: result }
    } catch (e: any) {
      return { success: false, error: normalizeError(e) } // Error is also on _updateUserProfile.error.value
    }
  }

  async function updateUserAvatar(payload: {
    avatarUrl: string
  }): Promise<{ success: boolean; user?: UserProfileAvatarUpdateResponse; error?: any }> {
    try {
      const result = await _updateUserAvatar.mutateAsync(payload)
      return { success: true, user: result }
    } catch (e: any) {
      return { success: false, error: normalizeError(e) }
    }
  }

  async function setReferrerCode(
    payload: SetReferrerDto
  ): Promise<{ success: boolean; error?: any }> {
    try {
      await _setReferrer.mutate(payload)
      return { success: true }
    } catch (e: any) {
      return { success: false, error: normalizeError(e) }
    }
  }

  async function fetchMyReferrals(): Promise<{
    success: boolean
    data?: ReferredUserProfileSubset[] | null
    error?: any
  }> {
    try {
      // createQuery might fetch on mount if enabled, or use .refetch() or ensure reactive key updates.
      // If not fetching automatically, you might need an explicit trigger.
      // For now, we assume it's either auto-fetched or components will trigger/observe.
      // This action can ensure it's loaded or re-fetched if needed.
      await _getMyReferrals.refetch() // Example: force a refetch
      return { success: true, data: _getMyReferrals.data.value }
    } catch (e: any) {
      return { success: false, error: normalizeError(e), data: null }
    }
  }

  async function fetchLeaderboard(
    page: number = 1,
    limit: number = 10
  ): Promise<{
    success: boolean
    data?: PaginatedResponse<LeaderboardUserSubset> | null
    error?: any
  }> {
    try {
      // For queries with parameters that change, you typically pass them to a method like `refetch` or `execute`
      // if the query isn't set up to reactively watch those parameters in its key.
      // Or, if queryFn can take params directly and Colada handles it:
      // The `createQuery` for _getLeaderboard takes params in its queryFn.
      // Calling _getLeaderboard.refetch({ variables: { page, limit }}) or similar might be needed
      // if Colada doesn't automatically pick up changes to page/limit if they were reactive.
      // For this example, assuming `createQuery` for `_getLeaderboard` re-fetches if called with different params,
      // or simply returns the current cached data for those params.
      // The most robust way is usually to have `createQuery` accept reactive params or provide a refetch method.
      // Let's assume `_getLeaderboard.queryFn` is smart enough or `_getLeaderboard.refetch({ variables: ... })` is the way.
      // For now, just directly use the data which would be for the last executed params.
      // To fetch specific page:
      await _getLeaderboard.refetch(true) // Pass variables directly
      return { success: true, data: _getLeaderboard.data.value }
    } catch (e: any) {
      return { success: false, error: normalizeError(e), data: null }
    }
  }

  async function dispatchUserCashtag(
    cashtag: string
  ): Promise<{ success: boolean; user?: UserProfileCashtagUpdateResponse; error?: any }> {
    try {
      const updatedCashtagFields = await _updateUserCashtag.mutateAsync({ cashtag })

      return { success: true, user: updatedCashtagFields }
    } catch (e: any) {
      return { success: false, error: normalizeError(e) }
    }
  }

  // This might not be needed if errors are primarily on the Colada procedure objects
  function clearActionError(errorTypeKey: keyof any) {
    const procedureMap = {
      profileUpdateState: _updateUserProfile,
      cashtagUpdateState: _updateUserCashtag,
      avatarUpdateState: _updateUserAvatar,
      setReferrerState: _setReferrer,
      referralsState: _getMyReferrals,
      leaderboardState: _getLeaderboard,
    }

    // const procedure = procedureMap[errorTypeKey]
    // if (procedure?.error?.value) {
    //   procedure.error.value = null
    // }
  }

  function normalizeError(e: any): Error {
    if (e instanceof Error) {
      return {
        name: e.name,
        message: e.message,
        stack: e.stack,
        ...('code' in e && { code: e.code }),
        ...('details' in e && { details: e.details }),
      } as Error
    }
    return {
      name: 'UnknownError',
      message: typeof e === 'string' ? e : 'An unknown error occurred',
    } as Error
  }

  // Expose reactive state from Colada utilities and actions
  return {
    // State is now primarily accessed via the Colada procedure utilities' reactive properties
    profileUpdateState: {
      data: computed(() => _updateUserProfile.data.value),
      isLoading: computed(() => _updateUserProfile.isLoading.value),
      error: computed(() => normalizeError(_updateUserProfile.error.value)),
    },
    cashtagUpdateState: {
      data: computed(() => _updateUserCashtag.data.value),
      isLoading: computed(() => _updateUserCashtag.isLoading.value),
      error: computed(() => normalizeError(_updateUserCashtag.error.value)),
    },
    avatarUpdateState: {
      data: computed(() => _updateUserAvatar.data.value),
      isLoading: computed(() => _updateUserAvatar.isLoading.value),
      error: computed(() => normalizeError(_updateUserAvatar.error.value)),
    },
    setReferrerState: {
      data: ref(null) as Ref<void | null>, // Mutation for void doesn't typically hold data
      isLoading: computed(() => _setReferrer.isLoading.value),
      error: computed(() => normalizeError(_setReferrer.error.value)),
    },
    referralsState: {
      data: computed(() => _getMyReferrals.data.value),
      isLoading: computed(() => _getMyReferrals.isLoading.value),
      error: computed(() => normalizeError(_getMyReferrals.error.value)),
    },
    leaderboardState: {
      data: computed(() => _getLeaderboard.data.value),
      isLoading: computed(() => _getLeaderboard.isLoading.value),
      error: computed(() => normalizeError(_getLeaderboard.error.value)),
    },

    // Actions
    updateUserProfile,
    updateUserAvatar,
    setReferrerCode,
    fetchMyReferrals,
    fetchLeaderboard,
    dispatchUserCashtag,
    clearActionError, // May need adjustment or removal
  }
})
